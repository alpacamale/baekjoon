# Python 최적화 기법 사용 리드미

## 1. **빠른 입력을 위한 `sys.stdin.readline()` 사용**

`sys.stdin.readline()`은 기본적인 `input()` 함수보다 빠르게 문자열을 입력받을 수 있습니다. 주로 **대량의 데이터를 처리**할 때 유용하며, 개행문자(`\n`)를 포함한 입력을 받습니다. `input()`은 `print()`와 비슷하게 자동으로 개행을 포함하지만, `sys.stdin.readline()`은 이를 포함하고 있기 때문에 개행을 제거하려면 `.strip()`을 사용할 수 있습니다.

```python
import sys
input = sys.stdin.readline

# 예시: 한 줄의 입력을 받을 때
n = int(input())  # 입력받은 숫자 n
data = list(map(int, input().split()))  # 한 줄에 여러 개의 숫자를 받을 때
```

### **장점**

- `sys.stdin.readline()`은 `input()`보다 성능이 뛰어나며, 특히 **대량의 데이터**를 처리할 때 유리합니다.

## 2. **`" ".join()` 대신 `*list` 사용하기**

리스트나 문자열을 합치는 작업에서 `" ".join()` 대신 `*list`를 활용하는 방법을 배웠습니다. `*list`는 **언팩 연산자(unpacking operator)**로, 리스트나 튜플의 원소들을 함수의 인자처럼 풀어서 전달하는 방식입니다.

### 예시

```python
# 리스트를 공백으로 구분하여 출력하는 예시
lst = [1, 2, 3, 4, 5]
print(*lst)  # 1 2 3 4 5

# " ".join()을 사용하는 방법과 비슷하지만, 좀 더 직관적이고 코드가 간결해짐
```

### **장점**

- 코드가 간결하고, 리스트의 원소들을 **간단하게 풀어서 출력**할 수 있습니다.

## 3. **`zip_longest` 활용하기**

`zip_longest`는 `itertools` 모듈에서 제공하는 함수로, **길이가 다른 이터러블(iterable)을 병렬로 처리**할 때 유용합니다. 기본적으로 `zip()`은 길이가 짧은 이터러블에 맞춰서 작업을 하지만, `zip_longest`는 **길이가 다른 이터러블을 맞추기 위해 `fillvalue`를 제공**할 수 있어 길이가 다른 데이터를 동시에 처리하는 데에 유리합니다.

### 예시

```python
from itertools import zip_longest

# 예시: 두 리스트의 값을 병렬로 결합
a = [1, 2, 3]
b = ['a', 'b']

result = list(zip_longest(a, b, fillvalue='x'))  # 두 리스트를 병렬로 결합, 부족한 부분은 'x'로 채움
print(result)  # [(1, 'a'), (2, 'b'), (3, 'x')]
```

### **장점**

- **길이가 다른 두 리스트를 안전하게 병렬 처리**할 수 있습니다. `zip()`에서는 길이가 다른 이터러블을 병렬 처리할 수 없지만, `zip_longest`를 사용하면 부족한 부분을 `fillvalue`로 채울 수 있어 유용합니다.

---

## 결론

1. `sys.stdin.readline()`을 활용하면 **빠르게 입력을 받을 수** 있어, 대량의 데이터를 처리할 때 성능상 큰 이점이 있습니다.
2. `" ".join()` 대신 `*list`를 사용하면 **코드가 간결해지고 더 직관적**으로 동작합니다.
3. `zip_longest`는 길이가 다른 두 리스트를 병렬로 처리할 때 **유용한 도구**로, `fillvalue`를 사용하여 부족한 값을 채울 수 있어 **안전한 데이터 처리**를 지원합니다.

이 세 가지 기법은 대규모 문제를 해결하는 데 유용하며, 성능 최적화와 코드 간결성을 동시에 높일 수 있습니다.
